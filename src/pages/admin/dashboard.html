@layout('layouts.admin')
@json('data/meta/admin_dashboard_title.json', $title)
@json('data/meta/admin_dashboard_body_class.json', $body_class)

<style>
  @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;500;700&display=swap');

  #default-header-wrapper,
  #normal-header-wrapper {
    display: none !important;
  }
</style>

<main id="main" class="admin-dashboard">
  @include('partials.admin-sidebar')

  <!-- メインコンテンツ -->
  <!-- メインコンテンツ (MISOGI Entrance) -->
  <div class="main-content" id="misogi-dashboard-container">

    <!-- Central Visualizer / Voice Mode -->
    <div class="voice-mode-content" id="voice-content">
      <div class="visualizer-container">
        <!-- Rotating Text -->
        <div class="circle-text-container" id="circle-text">
          <svg viewBox="0 0 200 200" class="circle-svg" width="320" height="320">
            <path id="circlePath" d="M 100, 100 m -80, 0 a 80,80 0 1,1 160,0 a 80,80 0 1,1 -160,0" />
            <text>
              <textPath href="#circlePath">
                Misesapo Intelligent System for Operational Guidance &amp; Integration &bull; Misesapo
                Intelligent System for Operational Guidance &amp; Integration &bull;
              </textPath>
            </text>
          </svg>
        </div>

        <div class="wave"></div>
        <div class="wave"></div>
        <div class="wave"></div>
        <div class="core-circle"></div>
      </div>

      <div class="status-text" id="status-text">Ready to Assist</div>

      <!-- AI Response Overlay (Voice mode only) -->
      <div class="ai-response-overlay" id="ai-response">
        <div class="ai-response-icon"><i class="fas fa-sparkles"></i> MISOGI</div>
        <div id="ai-message-text"></div>
      </div>
    </div>

    <!-- Chat Mode UI -->
    <div id="chat-container">
      <div class="chat-history" id="chat-history">
        <div class="chat-bubble ai">
          お疲れ様です。管理AIアシスタントの『Misogi』です。<br>
          経営状況の確認、スケジュールの調整、業務連絡の作成などをお手伝いします。
        </div>
      </div>
      <div class="chat-input-wrapper">
        <input type="text" id="text-input" placeholder="メッセージを入力..." autocomplete="off">
        <button class="send-btn" onclick="sendTextMessage()">
          <i class="fas fa-paper-plane"></i>
        </button>
      </div>
    </div>

    <!-- Bottom Mode Switcher -->
    <div class="mode-switch-container">
      <button class="mode-btn active" id="btn-voice-mode" onclick="switchMode('voice')">
        <i class="fas fa-microphone"></i> 音声
      </button>
      <button class="mode-btn" id="btn-chat-mode" onclick="switchMode('chat')">
        <i class="fas fa-comment-dots"></i> チャット
      </button>
    </div>

  </div>

  <link rel="stylesheet" href="/assets/css/admin-misogi.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/js/all.min.js"></script>
  <script>
    // Configuration
    const API_BASE = 'https://51bhoxkbxd.execute-api.ap-northeast-1.amazonaws.com/prod';

    // Auth Helper
    function ensureAuth() {
      // Admin might store token differently, but usually shared logic
      const token = localStorage.getItem('cognito_id_token');
      if (!token) {
        // Fallback or redirect
        console.warn("No auth token found");
        return null;
      }
      return token;
    }

    // --- UI Logic ---
    const visualizer = document.querySelector('.visualizer-container');
    const core = document.querySelector('.core-circle');
    const circleText = document.getElementById('circle-text');
    const statusText = document.getElementById('status-text');
    const responseOverlay = document.getElementById('ai-response');
    const messageText = document.getElementById('ai-message-text');
    const voiceContent = document.getElementById('voice-content');
    const chatContainer = document.getElementById('chat-container');
    const chatHistory = document.getElementById('chat-history');
    const textInput = document.getElementById('text-input');
    const btnVoice = document.getElementById('btn-voice-mode');
    const btnChat = document.getElementById('btn-chat-mode');

    let currentMode = 'voice';

    function switchMode(mode) {
      if (currentMode === mode) return;
      currentMode = mode;

      if (mode === 'voice') {
        btnVoice.classList.add('active');
        btnChat.classList.remove('active');
        // Hide chat
        chatContainer.classList.remove('active');
        // Show voice
        voiceContent.classList.remove('hidden');
        voiceContent.style.display = 'flex';
      } else {
        btnChat.classList.add('active');
        btnVoice.classList.remove('active');
        // Hide voice
        voiceContent.classList.add('hidden');
        setTimeout(() => {
          if (currentMode === 'chat') voiceContent.style.display = 'none';
        }, 500);
        // Show chat
        chatContainer.classList.add('active');
        if (textInput) textInput.focus();
      }
    }

    function appendChatMessage(role, text) {
      if (!chatHistory) return;
      const bubble = document.createElement('div');
      bubble.className = `chat-bubble ${role}`;
      bubble.innerHTML = text.replace(/\n/g, '<br>');
      chatHistory.appendChild(bubble);
      chatHistory.scrollTop = chatHistory.scrollHeight;
    }

    async function sendTextMessage() {
      const text = textInput.value.trim();
      if (!text) return;

      appendChatMessage('user', text);
      textInput.value = '';

      const token = ensureAuth();
      // Mock token for dev if needed
      const authHeader = token ? `Bearer ${token}` : '';

      const loadingBubble = document.createElement('div');
      loadingBubble.className = 'chat-bubble ai';
      loadingBubble.innerHTML = '<i class="fas fa-spinner fa-spin"></i> 解析中...';
      chatHistory.appendChild(loadingBubble);
      chatHistory.scrollTop = chatHistory.scrollHeight;

      try {
        // Using assistant_concierge action as requested
        const response = await fetch(`${API_BASE}/ai/process`, {
          method: 'POST',
          headers: {
            'Authorization': authHeader,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            action: 'assistant_concierge',
            text: text
          })
        });

        if (!response.ok) throw new Error('API Error');

        const data = await response.json();
        if (loadingBubble.parentNode) loadingBubble.remove();

        let aiResult = data.result;
        // Handle JSON string if double encoded
        if (typeof aiResult === 'string') {
          try {
            const jsonMatch = aiResult.match(/\{[\s\S]*\}/);
            if (jsonMatch) aiResult = JSON.parse(jsonMatch[0]);
          } catch (e) { }
        }

        // Extract reply
        const replyText = aiResult.reply || aiResult.text || JSON.stringify(aiResult);
        appendChatMessage('ai', replyText);

      } catch (err) {
        console.error(err);
        if (loadingBubble.parentNode) loadingBubble.remove();
        appendChatMessage('ai', 'エラーが発生しました。もう一度お試しください。');
      }
    }

    if (textInput) {
      textInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') sendTextMessage();
      });
    }

    // --- Audio Logic (Simplified) ---
    // Note: Actual voice recording requires https or localhost.

    let mediaRecorder;
    let audioChunks = [];
    let isRecording = false;

    if (visualizer) {
      visualizer.addEventListener('mousedown', startRecording);
      visualizer.addEventListener('mouseup', stopRecording);
      visualizer.addEventListener('touchstart', (e) => { e.preventDefault(); startRecording(); });
      visualizer.addEventListener('touchend', (e) => { e.preventDefault(); stopRecording(); });
    }

    async function startRecording() {
      if (isRecording) return;
      isRecording = true;
      statusText.textContent = "Listening...";
      core.style.transform = "scale(1.2)";
      circleText.classList.add('active');

      try {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        mediaRecorder = new MediaRecorder(stream);
        audioChunks = [];

        mediaRecorder.ondataavailable = e => audioChunks.push(e.data);
        mediaRecorder.start();
      } catch (e) {
        console.error(e);
        statusText.textContent = "Microphone Error";
        isRecording = false;
      }
    }

    async function stopRecording() {
      if (!isRecording || !mediaRecorder) return;

      mediaRecorder.stop();
      mediaRecorder.onstop = async () => {
        const audioBlob = new Blob(audioChunks, { type: 'audio/wav' }); // simplistic
        // Convert to base64
        const reader = new FileReader();
        reader.readAsDataURL(audioBlob);
        reader.onloadend = async () => {
          const base64data = reader.result.split(',')[1];
          await sendAudioToAI(base64data);
        };
      };

      isRecording = false;
      statusText.textContent = "Processing...";
      core.style.transform = "scale(1)";
      circleText.classList.remove('active');
    }

    async function sendAudioToAI(base64data) {
      const token = ensureAuth();
      try {
        const response = await fetch(`${API_BASE}/ai/process`, {
          method: 'POST',
          headers: {
            'Authorization': token ? `Bearer ${token}` : '',
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            action: 'assistant_concierge',
            audio: base64data,
            mime_type: 'audio/wav'
          })
        });
        const data = await response.json();

        let aiResult = data.result;
        if (typeof aiResult === 'string') {
          try {
            const jsonMatch = aiResult.match(/\{[\s\S]*\}/);
            if (jsonMatch) aiResult = JSON.parse(jsonMatch[0]);
          } catch (e) { }
        }
        const reply = aiResult.reply || "音声認識できませんでした";

        // Show overlay
        messageText.textContent = reply;
        responseOverlay.classList.add('visible');
        setTimeout(() => {
          responseOverlay.classList.remove('visible');
          statusText.textContent = "Ready";
        }, 5000);

      } catch (e) {
        console.error(e);
        statusText.textContent = "Error";
      }
    }

  </script>
</main>